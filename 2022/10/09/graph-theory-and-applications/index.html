<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>图论及其应用 | PlanZ</title><meta name="author" content="青椒肉丝"><meta name="copyright" content="青椒肉丝"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图论及其应用对于任意无向图G(输入为矩阵)，编写程序实现：  任务一：画出图G，并给所有顶点和边标号 任务二：求出图G的度序列 任务三：画出图G的补图 任务四：判断图G的连通性 任务五：求出图G的边连通度和点连通度 任务六：求出图G的最小点割集和最小边割集(元素最少)  解决方案任务一（画出图G，并给所有顶点和边标号） 通过 BrushTools 类中的 draw_vertex()# 画点, dr">
<meta property="og:type" content="article">
<meta property="og:title" content="图论及其应用">
<meta property="og:url" content="https://moonglowshadow.com/2022/10/09/graph-theory-and-applications/index.html">
<meta property="og:site_name" content="PlanZ">
<meta property="og:description" content="图论及其应用对于任意无向图G(输入为矩阵)，编写程序实现：  任务一：画出图G，并给所有顶点和边标号 任务二：求出图G的度序列 任务三：画出图G的补图 任务四：判断图G的连通性 任务五：求出图G的边连通度和点连通度 任务六：求出图G的最小点割集和最小边割集(元素最少)  解决方案任务一（画出图G，并给所有顶点和边标号） 通过 BrushTools 类中的 draw_vertex()# 画点, dr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_10.png">
<meta property="article:published_time" content="2022-10-09T05:45:07.000Z">
<meta property="article:modified_time" content="2025-03-26T07:04:06.485Z">
<meta property="article:author" content="青椒肉丝">
<meta property="article:tag" content="图论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_10.png"><link rel="shortcut icon" href="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/favicon_cat.png"><link rel="canonical" href="https://moonglowshadow.com/2022/10/09/graph-theory-and-applications/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=5.2.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-PKF693RYWD"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-PKF693RYWD')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-PKF693RYWD', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '图论及其应用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/aplayer/aplayer_custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/one_pic_background/modify.css"><link rel="stylesheet" href="/css/page_custom/my_custom.css"><link rel="stylesheet" href="/css/font/font_setting.css"><link rel="stylesheet" href="/css/cursor/cursor_setting.css"><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/preloader/preloader_flash.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/background_tingyun.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/avatar_486.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/playlist/"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_10.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/logo_cat.png" alt="Logo"><span class="site-name">PlanZ</span></a><a class="nav-page-title" href="/"><span class="site-name">图论及其应用</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/playlist/"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">图论及其应用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-09T05:45:07.000Z" title="发表于 2022-10-09 13:45:07">2022-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-26T07:04:06.485Z" title="更新于 2025-03-26 15:04:06">2025-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url(https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_10.png);"></div><article class="container post-content" id="article-container"><h1 id="图论及其应用"><a href="#图论及其应用" class="headerlink" title="图论及其应用"></a>图论及其应用</h1><p>对于任意无向图G(输入为矩阵)，编写程序实现：</p>
<ul>
<li>任务一：画出图G，并给所有顶点和边标号</li>
<li>任务二：求出图G的度序列</li>
<li>任务三：画出图G的补图</li>
<li>任务四：判断图G的连通性</li>
<li>任务五：求出图G的边连通度和点连通度</li>
<li>任务六：求出图G的最小点割集和最小边割集(元素最少)</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="任务一（画出图G，并给所有顶点和边标号）"><a href="#任务一（画出图G，并给所有顶点和边标号）" class="headerlink" title="任务一（画出图G，并给所有顶点和边标号）"></a>任务一（画出图G，并给所有顶点和边标号）</h3><ul>
<li>通过 <code>BrushTools</code> 类中的 <code>draw_vertex()# 画点, draw_edge()# 画边, show()# 展示绘制图像</code> 方法实现</li>
<li>使用二维矩阵接收点和边，点用坐标表示，边用邻接矩阵表示，如下所示：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收点</span></span><br><span class="line">v = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">4</span>], [<span class="number">7</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 接收边</span></span><br><span class="line">e = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用python绘图库matplotlib实现图的绘制<ul>
<li>使用matplotlib中的 <code>scatter(x坐标, y坐标, c="颜色")</code> 函数绘制图的顶点</li>
<li>使用matplotlib中的 <code>plot(x坐标, y坐标, c="颜色")</code> 函数绘制图的边，其中边的始点和终点坐标通过邻接矩阵<code>e</code>找到对应顶点坐标矩阵<code>v</code>中相应的坐标</li>
<li>通过matplotlib中的 <code>add_artist(plt.Circle((圆心坐标), 半径, fill=是否填充, color="颜色"))</code> 函数为画布上添加圆形来表示环</li>
<li>使用matplotlib中的 <code>annotate(注释内容, xy=[添加注释的点的坐标], xytext=[注释文字的坐标])</code> 注释函数为点和边添加注释。注：在非简单无向图中，平行边通过为一条边添加多个不同的边注释来表示</li>
<li>使用matplotlib中的 <code>show()</code> 函数将绘制完的图像进行展示</li>
</ul>
</li>
</ul>
<h3 id="任务二（求出图G的度序列）"><a href="#任务二（求出图G的度序列）" class="headerlink" title="任务二（求出图G的度序列）"></a>任务二（求出图G的度序列）</h3><ul>
<li>通过 <code>CalcTools</code> 类中的 <code>calc_degrees()</code> 方法实现度序列的计算</li>
<li>因为是无向图，因此点vi的度数只需要考虑邻接矩阵 <code>e</code> 中从vi点出发的边的条数，即关注邻接矩阵中的第i行，其中，环提供两度，该方法的主要结构如下：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d_line = []</span><br><span class="line">d = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.e.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.e.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> self.e[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                d += <span class="number">2</span> * self.e[i][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d += <span class="number">1</span> * self.e[i][j]</span><br><span class="line">    d_line.append(d)</span><br><span class="line">    d = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>其中d_line用来保存最终返回的度序列，当i==j时，说明该边为环，当内层循环结束时，将该点的度数和添加到d_line中</li>
</ul>
<h3 id="任务三（画出图G的补图）"><a href="#任务三（画出图G的补图）" class="headerlink" title="任务三（画出图G的补图）"></a>任务三（画出图G的补图）</h3><ul>
<li>通过 <code>BrushTools</code> 类中的 <code>draw_complement</code> 方法实现补图的计算和绘制</li>
<li>先将原图预处理为简单图，遍历邻接矩阵 <code>e</code> ，将对角线数字置为0（去环），将其他非0位置的值置为1（去平行边）</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, e.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, e.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment"># 去环</span></span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            e[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 去平行边</span></span><br><span class="line">            <span class="keyword">if</span> e[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                e[i][j] = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将处理后的邻接矩阵 <code>e</code> 中的非对角线位置的值进行非操作，即可获得该图补图的邻接矩阵</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ec.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ec.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> i != j:</span><br><span class="line">            <span class="keyword">if</span> ec[i][j] == <span class="number">1</span>:</span><br><span class="line">                ec[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ec[i][j] = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用任务一中实现的绘图方法 <code>BrushTools.show()</code> 实现补图的绘制与展示</li>
</ul>
<h3 id="任务四（判断图G的连通性）"><a href="#任务四（判断图G的连通性）" class="headerlink" title="任务四（判断图G的连通性）"></a>任务四（判断图G的连通性）</h3><ul>
<li>通过 <code>CalcTools</code> 类中的 <code>judge_connect()</code> 方法判断图的连通性</li>
<li>无向图中若任意两点均可达，则为连通的</li>
<li>从图中任意一点vi出发，将该点加入连通点列表 <code>v_connect</code> 中，判断能否到达其他不在 <code>v_connect</code> 中的点，即邻接矩阵 <code>e</code> 的第i行是否有非零数<ul>
<li>如果没有，则说明vi与其他点不相邻，说明该图为非连通的</li>
<li>如果有，则说明vi与对应点相邻，进行递归，重复以上过程，继续判断对应点是否能继续走到其他点？</li>
</ul>
</li>
<li>完成以上过程后，得到从vi点出发可以到达所有点的列表 <code>v_connect</code> ，对其进行处理，判断其中的元素个数是否与该图总顶点数相同，如果相同则说明从vi点出发可以到达所有顶点，该图连通，否则不连通</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算图的连通性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_connect</span>(<span class="params">self, flag</span>):</span><br><span class="line">    self.v_connect.append(flag)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.e.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i <span class="keyword">not</span> <span class="keyword">in</span> self.v_connect:</span><br><span class="line">            <span class="keyword">if</span> self.e[flag][i] != <span class="number">0</span>:</span><br><span class="line">                self.calc_connect(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断连通性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">judge_connect</span>(<span class="params">self</span>):</span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    self.calc_connect(<span class="number">0</span>)</span><br><span class="line">    result = <span class="built_in">list</span>(<span class="built_in">set</span>(self.v_connect))</span><br><span class="line">    self.v_connect = []</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) == self.e.shape[<span class="number">0</span>]:</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br></pre></td></tr></tbody></table></figure>
<h3 id="任务五、六"><a href="#任务五、六" class="headerlink" title="任务五、六"></a>任务五、六</h3><ul>
<li>任务五：求出图G的边连通度和点连通度</li>
<li>任务六：求出图G的最小点割集和最小边割集(元素最少)</li>
<li>任务五和任务六相关，找出最小边割集/点割集，即可获取图的边连通度/点连通度</li>
<li>该任务的整体思路为，以找出最小边割集为例，在连通图中从少到多删除图中的边，然后调用任务四中实现的判断图连通性的方法 <code>CalcTools.judge_connect()</code><br>或其变体<code>CalcTools.judge_connect_complex()</code><br>来判断删除边后的图的连通性，一旦图不连通，则找出一个图的最小边割集，该边割集的大小即为该图的边连通度，该方法的思想同样可以找出所有的最小边割集，此处实现只找出其中一个作为展示<ul>
<li>判断边连通度<ul>
<li>首先判断输入图是否为连通图 <code>judge_connect()</code> 非连通图直接返回空列表</li>
<li>第一层循环为删除的边的个数，其范围为1到n-1(n为点的个数)： <code>for num in range(1, self.e.shape[0])</code><ul>
<li>使用 <code>e2del = list(combinations(待组合列表, 组合大小))</code> 函数来获取本次循环中要删除的边的组合，其中待组合列表为邻接矩阵 <code>e</code><br>中所表示的所有边，组合大小为i，即本次循环要删除的边的个数， <code>e2del</code>即为本次循环中要删除的边的各种组合</li>
<li>第二层循环，从e2del中取出待删除的边，进行删除，然后判断图的连通性，如果不连通则找到其中一个最小边割集，将其进行返回，否则对邻接矩阵 <code>e</code> 进行复原，继续进行循环</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> edges <span class="keyword">in</span> e2del:</span><br><span class="line">    del_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    cut = []</span><br><span class="line"></span><br><span class="line">    temp_e = copy.deepcopy(self.e)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, temp_e.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, temp_e.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">while</span> temp_e[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                del_count += <span class="number">1</span></span><br><span class="line">                temp_e[i][j] -= <span class="number">1</span></span><br><span class="line">                temp_e[j][i] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">                    <span class="comment"># 说明该边在要删除的边组合中</span></span><br><span class="line">                    <span class="keyword">if</span> del_count == e:</span><br><span class="line">                        self.e[i][j] = <span class="number">0</span></span><br><span class="line">                        self.e[j][i] = <span class="number">0</span></span><br><span class="line">                        <span class="comment"># 对该边进行保存</span></span><br><span class="line">                        cut.append((i, j))</span><br><span class="line">    <span class="comment"># 删除完边，判断图的连通性</span></span><br><span class="line">    flag = self.judge_connect()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对边进行还原</span></span><br><span class="line">    self.e = copy.deepcopy(dc_e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        <span class="keyword">return</span> cut</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>计算点割集的整体思想与计算边割集的思想一致，在 <code>CalcTools.calc_vertex_connect()</code><br>方法中实现，该方法从少到多找出所有删除点的组合，然后对点和关联边进行删除，同时判断删除点和边之后的图的连通性，此处不再做过多解释</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_vertex_connect</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 深拷贝原邻接矩阵</span></span><br><span class="line">    dc_e = copy.deepcopy(self.e)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是不是连通图</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.judge_connect():</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算图中的所有点个数</span></span><br><span class="line">    v_count = self.v.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 待组合列表</span></span><br><span class="line">    v_combination = <span class="built_in">range</span>(<span class="number">0</span>, v_count)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删点和相关联的边，然后判断是否连通</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.v.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="comment"># 确定要删除的点组合</span></span><br><span class="line">        v2del = <span class="built_in">list</span>(combinations(v_combination, num))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环删除要删除的点和边组合</span></span><br><span class="line">        <span class="keyword">for</span> vertexes <span class="keyword">in</span> v2del:</span><br><span class="line">            cut = []</span><br><span class="line"></span><br><span class="line">            self.e = np.array(self.e)</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> vertexes:</span><br><span class="line">                self.e[v, :] = <span class="number">0</span></span><br><span class="line">                self.e[:, v] = <span class="number">0</span></span><br><span class="line">                cut.append(v)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果删除的点数等于n-1，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> num == self.v.shape[<span class="number">0</span>] - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> cut</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 删除完点和关联边，判断图的连通性</span></span><br><span class="line">            flag = self.judge_connect_complex(self.v.shape[<span class="number">0</span>], vertexes)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                <span class="keyword">return</span> cut</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对边进行还原</span></span><br><span class="line">            self.e = copy.deepcopy(dc_e)</span><br><span class="line">    self.e = copy.deepcopy(dc_e)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><strong>绘图工具类</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrushTools</span>:</span><br><span class="line">    <span class="comment"># 创建figure</span></span><br><span class="line">    figure = plt.figure()</span><br><span class="line">    <span class="comment"># 创建axes</span></span><br><span class="line">    axes = figure.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存点坐标</span></span><br><span class="line">    v = []</span><br><span class="line">    <span class="comment"># 保存边关系</span></span><br><span class="line">    e = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v, e</span>):</span><br><span class="line">        self.v = v</span><br><span class="line">        self.e = e</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在画布上画点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_vertex</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 标点</span></span><br><span class="line">        self.axes.scatter(self.v[:, <span class="number">0</span>], self.v[:, <span class="number">1</span>], c=<span class="string">"red"</span>)</span><br><span class="line">        <span class="comment"># 给点加注释</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.v.shape[<span class="number">0</span>]):</span><br><span class="line">            self.axes.annotate(<span class="string">"v"</span> + <span class="built_in">str</span>(i),</span><br><span class="line">                               xy=[self.v[i, <span class="number">0</span>], self.v[i, <span class="number">1</span>]],</span><br><span class="line">                               xytext=[self.v[i, <span class="number">0</span>] + <span class="number">0.05</span>, self.v[i, <span class="number">1</span>] - <span class="number">0.05</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在画布上画边</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_edge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 标边</span></span><br><span class="line">        ec = copy.deepcopy(self.e)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ec.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ec.shape[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">if</span> ec[i, j] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 判断是不是环</span></span><br><span class="line">                    <span class="keyword">if</span> i == j:</span><br><span class="line">                        self.axes.add_artist(plt.Circle((self.v[i, <span class="number">0</span>], self.v[i, <span class="number">1</span>] + <span class="number">0.2</span>), <span class="number">0.2</span>,</span><br><span class="line">                                                        fill=<span class="literal">False</span>,</span><br><span class="line">                                                        color=<span class="string">"green"</span>))</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 考虑多个环的情况，加多个注释</span></span><br><span class="line">                        a_str = <span class="string">""</span></span><br><span class="line">                        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ec[i][j]):</span><br><span class="line">                            a_str = a_str + <span class="string">"e"</span> + <span class="built_in">str</span>(count) + <span class="string">","</span></span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                        self.axes.annotate(a_str[:-<span class="number">1</span>],</span><br><span class="line">                                           xy=[self.v[i, <span class="number">0</span>] + <span class="number">0.15</span>, self.v[i, <span class="number">1</span>] + <span class="number">0.3</span>],</span><br><span class="line">                                           xytext=[self.v[i, <span class="number">0</span>] + <span class="number">0.15</span>, self.v[i, <span class="number">1</span>] + <span class="number">0.3</span>])</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ec[j, i] = <span class="number">0</span></span><br><span class="line">                        x = [self.v[i, <span class="number">0</span>], self.v[j, <span class="number">0</span>]]</span><br><span class="line">                        y = [self.v[i, <span class="number">1</span>], self.v[j, <span class="number">1</span>]]</span><br><span class="line">                        self.axes.plot(x, y, c=<span class="string">"green"</span>)</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 给边加注释(考虑平行边的情况)</span></span><br><span class="line">                        a_str = <span class="string">""</span></span><br><span class="line">                        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ec[i][j]):</span><br><span class="line">                            a_str = a_str + <span class="string">"e"</span> + <span class="built_in">str</span>(count) + <span class="string">","</span></span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                        xm = (self.v[i, <span class="number">0</span>] + self.v[j, <span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">                        ym = (self.v[i, <span class="number">1</span>] + self.v[j, <span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">                        self.axes.annotate(a_str[:-<span class="number">1</span>], xy=[xm, ym], xytext=[xm + <span class="number">0.02</span>, ym + <span class="number">0.02</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画出图的补图（考虑简单无向图）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_complement</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 预处理，确保是简单无向图</span></span><br><span class="line">        ec = copy.deepcopy(self.e)</span><br><span class="line">        ec = self.transform2simple(ec)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成补图</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ec.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ec.shape[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    <span class="keyword">if</span> ec[i][j] == <span class="number">1</span>:</span><br><span class="line">                        ec[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ec[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 画出补图</span></span><br><span class="line">        e_temp = copy.deepcopy(self.e)</span><br><span class="line">        self.e = ec</span><br><span class="line">        self.show()</span><br><span class="line">        self.e = e_temp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将无向图转换为简单无向图(去环，去平行边)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transform2simple</span>(<span class="params">self, e</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, e.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, e.shape[<span class="number">1</span>]):</span><br><span class="line">                <span class="comment"># 去环</span></span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    e[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 去平行边</span></span><br><span class="line">                    <span class="keyword">if</span> e[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                        e[i][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        self.axes.cla()</span><br><span class="line">        self.draw_vertex()</span><br><span class="line">        self.draw_edge()</span><br><span class="line"></span><br><span class="line">        plt.axis(<span class="string">'scaled'</span>)</span><br><span class="line">        self.figure.show()</span><br></pre></td></tr></tbody></table></figure>
<p><strong>图计算工具类</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalcTools</span>:</span><br><span class="line">    <span class="comment"># 保存点坐标</span></span><br><span class="line">    v = []</span><br><span class="line">    <span class="comment"># 保存边关系</span></span><br><span class="line">    e = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 临时变量</span></span><br><span class="line">    v_connect = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v, e</span>):</span><br><span class="line">        self.v = v</span><br><span class="line">        self.e = e</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算图的度序列</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_degrees</span>(<span class="params">self</span>):</span><br><span class="line">        d_line = []</span><br><span class="line">        d = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.e.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.e.shape[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">if</span> self.e[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> i == j:</span><br><span class="line">                        d += <span class="number">2</span> * self.e[i][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        d += <span class="number">1</span> * self.e[i][j]</span><br><span class="line">            d_line.append(d)</span><br><span class="line">            d = <span class="number">0</span></span><br><span class="line">        <span class="comment"># print("任务二：图的度序列为" + str(d_line))</span></span><br><span class="line">        <span class="keyword">return</span> d_line</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算图的连通性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_connect</span>(<span class="params">self, flag</span>):</span><br><span class="line">        self.v_connect.append(flag)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.e.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i <span class="keyword">not</span> <span class="keyword">in</span> self.v_connect:</span><br><span class="line">                <span class="keyword">if</span> self.e[flag][i] != <span class="number">0</span>:</span><br><span class="line">                    self.calc_connect(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断连通性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">judge_connect</span>(<span class="params">self</span>):</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        self.calc_connect(<span class="number">0</span>)</span><br><span class="line">        result = <span class="built_in">list</span>(<span class="built_in">set</span>(self.v_connect))</span><br><span class="line">        self.v_connect = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(result) == self.e.shape[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># print("任务四：该无向图是连通的")</span></span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print("任务四：该图只有" + str(len(result)) + "个点是连通的，分别是" + str(result))</span></span><br><span class="line">            <span class="comment"># print("任务四：该无向图是不连通的")</span></span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断连通性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">judge_connect_complex</span>(<span class="params">self, v_size, del_v</span>):</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, v_size):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> del_v:</span><br><span class="line">                <span class="comment"># print(i)</span></span><br><span class="line">                self.calc_connect(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">list</span>(<span class="built_in">set</span>(self.v_connect))</span><br><span class="line">        self.v_connect = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(result) == v_size - <span class="built_in">len</span>(del_v):</span><br><span class="line">            <span class="comment"># print(v_size - len(del_v))</span></span><br><span class="line">            <span class="comment"># print("任务四：该无向图是连通的")</span></span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print("任务四：该图只有" + str(len(result)) + "个点是连通的，分别是" + str(result))</span></span><br><span class="line">            <span class="comment"># print("任务四：该无向图是不连通的")</span></span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算边连通度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_edge_connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 深拷贝原邻接矩阵</span></span><br><span class="line">        dc_e = copy.deepcopy(self.e)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是不是连通图</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.judge_connect():</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算图中的所有边数</span></span><br><span class="line">        e_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.e.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.e.shape[<span class="number">1</span>]):</span><br><span class="line">                e_count = e_count + self.e[i][j]</span><br><span class="line">        e_count = <span class="built_in">int</span>(e_count / <span class="number">2.0</span>)</span><br><span class="line">        <span class="comment"># print("总边数" + str(e_count))</span></span><br><span class="line"></span><br><span class="line">        e_combination = <span class="built_in">range</span>(<span class="number">1</span>, e_count + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删边，然后判断是否连通</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.e.shape[<span class="number">0</span>]):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 确定要删除的边组合</span></span><br><span class="line">            e2del = <span class="built_in">list</span>(combinations(e_combination, num))</span><br><span class="line">            <span class="comment"># print(e2del)</span></span><br><span class="line">            <span class="comment"># 循环删除要删除的边组合</span></span><br><span class="line">            <span class="keyword">for</span> edges <span class="keyword">in</span> e2del:</span><br><span class="line">                del_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                cut = []</span><br><span class="line"></span><br><span class="line">                temp_e = copy.deepcopy(self.e)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, temp_e.shape[<span class="number">0</span>]):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, temp_e.shape[<span class="number">1</span>]):</span><br><span class="line">                        <span class="keyword">while</span> temp_e[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                            del_count += <span class="number">1</span></span><br><span class="line">                            temp_e[i][j] -= <span class="number">1</span></span><br><span class="line">                            temp_e[j][i] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">                                <span class="comment"># 说明该边在要删除的边组合中</span></span><br><span class="line">                                <span class="keyword">if</span> del_count == e:</span><br><span class="line">                                    self.e[i][j] = <span class="number">0</span></span><br><span class="line">                                    self.e[j][i] = <span class="number">0</span></span><br><span class="line">                                    <span class="comment"># print(str(self.e))</span></span><br><span class="line">                                    <span class="comment"># 对该边进行保存</span></span><br><span class="line">                                    cut.append((i, j))</span><br><span class="line">                <span class="comment"># 删除完边，判断图的连通性</span></span><br><span class="line">                <span class="comment"># print("测试连通性" + "\n" + str(self.e))</span></span><br><span class="line"></span><br><span class="line">                flag = self.judge_connect()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 对边进行还原</span></span><br><span class="line">                self.e = copy.deepcopy(dc_e)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> cut</span><br><span class="line"></span><br><span class="line">        self.e = copy.deepcopy(dc_e)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算点连通度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_vertex_connect</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 深拷贝原邻接矩阵</span></span><br><span class="line">        dc_e = copy.deepcopy(self.e)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是不是连通图</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.judge_connect():</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算图中的所有点个数</span></span><br><span class="line">        v_count = self.v.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print("总点数" + str(v_count))</span></span><br><span class="line"></span><br><span class="line">        v_combination = <span class="built_in">range</span>(<span class="number">0</span>, v_count)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删点和相关联的边，然后判断是否连通</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.v.shape[<span class="number">0</span>]):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 确定要删除的点组合</span></span><br><span class="line">            v2del = <span class="built_in">list</span>(combinations(v_combination, num))</span><br><span class="line">            <span class="comment"># print(v2del)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 循环删除要删除的点和边组合</span></span><br><span class="line">            <span class="keyword">for</span> vertexes <span class="keyword">in</span> v2del:</span><br><span class="line">                del_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                cut = []</span><br><span class="line"></span><br><span class="line">                <span class="comment"># print(vertexes)</span></span><br><span class="line"></span><br><span class="line">                self.e = np.array(self.e)</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> vertexes:</span><br><span class="line">                    self.e[v, :] = <span class="number">0</span></span><br><span class="line">                    self.e[:, v] = <span class="number">0</span></span><br><span class="line">                    cut.append(v)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 删除完点和关联边，判断图的连通性</span></span><br><span class="line">                <span class="comment"># print("测试连通性" + "\n" + str(self.e))</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> num == self.v.shape[<span class="number">0</span>] - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> cut</span><br><span class="line"></span><br><span class="line">                flag = self.judge_connect_complex(self.v.shape[<span class="number">0</span>], vertexes)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> cut</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 对边进行还原</span></span><br><span class="line">                self.e = copy.deepcopy(dc_e)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># print("===================================")</span></span><br><span class="line"></span><br><span class="line">        self.e = copy.deepcopy(dc_e)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>主函数</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> brush_tools <span class="keyword">import</span> BrushTools</span><br><span class="line"><span class="keyword">from</span> calculate_tools <span class="keyword">import</span> CalcTools</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># # 接收点</span></span><br><span class="line">    <span class="comment"># v = np.array([[1, 1], [1, 4], [7, 3], [5, 1]])</span></span><br><span class="line">    <span class="comment"># # 接收边</span></span><br><span class="line">    <span class="comment"># e = np.array([[1, 2, 0, 0],</span></span><br><span class="line">    <span class="comment">#               [2, 0, 0, 1],</span></span><br><span class="line">    <span class="comment">#               [0, 0, 0, 0],</span></span><br><span class="line">    <span class="comment">#               [0, 1, 0, 0]])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 接收点</span></span><br><span class="line">    <span class="comment"># v = np.array([[1, 1], [1, 3], [2, 2], [3, 2]])</span></span><br><span class="line">    <span class="comment"># # 接收边</span></span><br><span class="line">    <span class="comment"># e = np.array([[0, 1, 1, 0],</span></span><br><span class="line">    <span class="comment">#               [1, 0, 1, 0],</span></span><br><span class="line">    <span class="comment">#               [1, 1, 1, 1],</span></span><br><span class="line">    <span class="comment">#               [0, 0, 1, 0]])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收点</span></span><br><span class="line">    v = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">1</span>], [<span class="number">7</span>, <span class="number">3</span>], [<span class="number">9</span>, <span class="number">1</span>], [<span class="number">9</span>, <span class="number">3</span>]])</span><br><span class="line">    <span class="comment"># 接收边</span></span><br><span class="line">    e = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">                  ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 任务一：画出图G，并给所有顶点和边标号</span></span><br><span class="line">    brush = BrushTools(v, e)</span><br><span class="line">    brush.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务一：如图所示"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 任务二：求出图G的度序列</span></span><br><span class="line">    calc = CalcTools(v, e)</span><br><span class="line">    degrees = calc.calc_degrees()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务二：图的度序列为"</span> + <span class="built_in">str</span>(degrees))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 任务三：画出图G的补图</span></span><br><span class="line">    brush.draw_complement()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务三：如图所示，原图已被处理为简单无向图"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 任务四：连通性</span></span><br><span class="line">    calc = CalcTools(v, e)</span><br><span class="line">    flag = calc.judge_connect()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务四：该图的连通性为"</span> + <span class="built_in">str</span>(flag))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 任务五：求边连通度和点连通度</span></span><br><span class="line">    calc = CalcTools(v, e)</span><br><span class="line">    e_cut_set = calc.calc_edge_connect()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务五、六：边连通度是"</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(e_cut_set)) + <span class="string">",最小边割集是"</span> + <span class="built_in">str</span>(e_cut_set))</span><br><span class="line"></span><br><span class="line">    v_cut_set = calc.calc_vertex_connect()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务五、六：点连通度是"</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(v_cut_set)) + <span class="string">",最小点割集是"</span> + <span class="built_in">str</span>(v_cut_set))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><ul>
<li>画出图G，并给所有顶点和边标号</li>
<li>输入点和边如下所示：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">4</span>], [<span class="number">7</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">1</span>]])</span><br><span class="line">e = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>绘图结果展示：</li>
</ul>
<p><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/posts/graph-theory-and-applications/graph-01.png" alt="任务一"></p>
<h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><ul>
<li>求出图G的度序列</li>
<li>输入点和边与任务一相同，度序列如下，与任务一展示图结果相对应，注：图中e1和e2为平行边</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任务二：图的度序列为[4, 3, 0, 1]</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h3><ul>
<li>画出图G的补图</li>
<li>输入点和边与任务一相同，补图如下所示，与任务一的结果相对应</li>
</ul>
<p><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/posts/graph-theory-and-applications/graph-02.png" alt="任务三"></p>
<h3 id="任务四"><a href="#任务四" class="headerlink" title="任务四"></a>任务四</h3><ul>
<li>判断图G的连通性</li>
<li>输入点和边与任务一相同，运行方法判断图的连通性，结果如下所示：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任务四：该图的连通性为False</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>重新输入新的点坐标和边邻接矩阵，使新的图连通，如下所示</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接收点</span></span><br><span class="line">v = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># 接收边</span></span><br><span class="line">e = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>重新输入图的展示与连通性判断结果如下：</li>
</ul>
<p><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/posts/graph-theory-and-applications/graph-03.png" alt="任务四"></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任务四：该图的连通性为True</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="任务五、六-1"><a href="#任务五、六-1" class="headerlink" title="任务五、六"></a>任务五、六</h3><ul>
<li>求出图G的边连通度和点连通度</li>
<li>求出图G的最小点割集和最小边割集(元素最少)</li>
<li>输入的图如下所示：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接收点</span></span><br><span class="line">v = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">1</span>], [<span class="number">7</span>, <span class="number">3</span>], [<span class="number">9</span>, <span class="number">1</span>], [<span class="number">9</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 接收边</span></span><br><span class="line">e = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">              ])</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/posts/graph-theory-and-applications/graph-04.png" alt="任务五"></p>
<ul>
<li>边割集/点割集，边连通度/点连通度计算结果如下：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任务五、六：边连通度是2,最小边割集是[(2, 4), (3, 4)]</span></span><br><span class="line"><span class="comment"># 任务五、六：点连通度是1,最小点割集是[4]</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>其中边割集(2,4)表示从点v2到v4的边，即图中的e6，同理(3,4)表示图中的e7</li>
<li>点割集中的4表示图中的v4</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://moonglowshadow.com">青椒肉丝</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://moonglowshadow.com/2022/10/09/graph-theory-and-applications/">https://moonglowshadow.com/2022/10/09/graph-theory-and-applications/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://moonglowshadow.com" target="_blank">PlanZ</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a></div><div class="post-share"><div class="social-share" data-image="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_10.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/09/27/drone_task/" title="无人机任务"><img class="cover" src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">无人机任务</div></div><div class="info-2"><div class="info-item-1">无人机任务场景Scenario: A drone is mounted with an internal GPS system and a 1D spinning LIDAR (something like this http://www.slamtec.com/en/lidar/a1). Every time the drone changes direction, the LIDAR does 1 full scan (sweep) of its surroundings. Our goal is to use the LIDAR data to improve the drone’s navigation. For this assignment altitude and drone orientation can be ignored. You can also assume that the scan is so fast that you can treat the drone as stationary for each sweep. One flight’s worth of data is provided consisting of $N$ sweeps over $x$ seconds. 场景：一架无人机配备了内部GPS系统和一个一维旋转LIDAR（类似于这个：http://www.slamtec.com/en/lidar/a1 ）。每当无人机改变方向时，LIDAR都会对其周围环境进行一次完整的扫描（扫描一圈）。我们的目标是利用LIDAR数据来改进无人机的导航。在本次任务中，可以忽略无人机的高度和方向。此外，可以假设扫描速度足够快，以至于在每次扫描期间可以将无人机视为静止的。提供了一次飞行的数据，其中包含N次扫描，持续x秒。 任务Tasks: For this assessment complete any 2 of the following Tasks. It is recommended that you pick 2 Tasks that assist each other. Any language may be used however Java, C#, C++ or Python are preferred. You...</div></div></div></a><a class="pagination-related" href="/2022/12/11/hungarian-algorithm/" title="匈牙利算法"><img class="cover" src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">匈牙利算法</div></div><div class="info-2"><div class="info-item-1">匈牙利算法匈牙利算法步骤 任给初始匹配M 若M饱和V1则结束，否则转(3) 在V1中找一个非M饱和点x，置S={x}，T={ } 若N(S)=T，则停止，否则在N(S)-T中任选一点y 若y为M饱和点转(6)，否则求一条从x到y的M可增广路P，并更新匹配M，转(2) 因为y是M饱和点，所以M中有一边(y，u)，置S=S∪{u}，T=T∪{y}，转(4)  代码部分输入二部图如下：  可以由以下代码表示： 123456# 输入二部图bi_graph = [[0, 1, 1, 0, 0],            [1, 1, 0, 1, 1],            [0, 1, 1, 0, 0],            [0, 1, 1, 0, 0],            [0, 0, 0, 1, 1]] (1). 任给初始匹配M 12345678910111213141516# 初始化匹配def init_matching(graph):    x, y = np.shape(graph)    matching = np.zeros((x, y), int)    matched = []    for i in range(0, x):        for j in range(0, y):            if graph[i][j] == 1 and j not in matched:                matching[i][j] = 1                matched.append(j)                break    return matching 创建一个与二部图矩阵对应的匹配矩阵，初始化匹配矩阵的规则是：遍历输入的二部图矩阵，从V1出发找到V2找边，如果该边在V2中饱和的点已经在匹配中出现，则不选择该边，当找到一条合适的边时，将其加入匹配矩阵结束本次循环，并在V1中找到下一个点继续重复以上过程。 以上过程结束后即可获得如下(a)所示初始匹配矩阵。由于此初始化方法在本例中直接给出了最大匹配，无法体现完整的算法过程，因此在之后的代码中将采用(b)作为初始匹配。   (b)初始化匹配结果如图所示：  (2). 判断匹配M是否饱和V1 12345678# 判断匹配是否饱和所有V1点def...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/12/11/hungarian-algorithm/" title="匈牙利算法"><img class="cover" src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_7.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-11</div><div class="info-item-2">匈牙利算法</div></div><div class="info-2"><div class="info-item-1">匈牙利算法匈牙利算法步骤 任给初始匹配M 若M饱和V1则结束，否则转(3) 在V1中找一个非M饱和点x，置S={x}，T={ } 若N(S)=T，则停止，否则在N(S)-T中任选一点y 若y为M饱和点转(6)，否则求一条从x到y的M可增广路P，并更新匹配M，转(2) 因为y是M饱和点，所以M中有一边(y，u)，置S=S∪{u}，T=T∪{y}，转(4)  代码部分输入二部图如下：  可以由以下代码表示： 123456# 输入二部图bi_graph = [[0, 1, 1, 0, 0],            [1, 1, 0, 1, 1],            [0, 1, 1, 0, 0],            [0, 1, 1, 0, 0],            [0, 0, 0, 1, 1]] (1). 任给初始匹配M 12345678910111213141516# 初始化匹配def init_matching(graph):    x, y = np.shape(graph)    matching = np.zeros((x, y), int)    matched = []    for i in range(0, x):        for j in range(0, y):            if graph[i][j] == 1 and j not in matched:                matching[i][j] = 1                matched.append(j)                break    return matching 创建一个与二部图矩阵对应的匹配矩阵，初始化匹配矩阵的规则是：遍历输入的二部图矩阵，从V1出发找到V2找边，如果该边在V2中饱和的点已经在匹配中出现，则不选择该边，当找到一条合适的边时，将其加入匹配矩阵结束本次循环，并在V1中找到下一个点继续重复以上过程。 以上过程结束后即可获得如下(a)所示初始匹配矩阵。由于此初始化方法在本例中直接给出了最大匹配，无法体现完整的算法过程，因此在之后的代码中将采用(b)作为初始匹配。   (b)初始化匹配结果如图所示：  (2). 判断匹配M是否饱和V1 12345678# 判断匹配是否饱和所有V1点def...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/avatar_486.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">青椒肉丝</div><div class="author-info-description">All those moments will be lost in time, like tears in rain.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rr-Razor"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">初次访问时部分资源可能加载速度较慢，请耐心等待、尝试刷新或者使用魔法❀❀❀</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">图论及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%88%E7%94%BB%E5%87%BA%E5%9B%BEG%EF%BC%8C%E5%B9%B6%E7%BB%99%E6%89%80%E6%9C%89%E9%A1%B6%E7%82%B9%E5%92%8C%E8%BE%B9%E6%A0%87%E5%8F%B7%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">任务一（画出图G，并给所有顶点和边标号）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%88%E6%B1%82%E5%87%BA%E5%9B%BEG%E7%9A%84%E5%BA%A6%E5%BA%8F%E5%88%97%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">任务二（求出图G的度序列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%88%E7%94%BB%E5%87%BA%E5%9B%BEG%E7%9A%84%E8%A1%A5%E5%9B%BE%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">任务三（画出图G的补图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%88%E5%88%A4%E6%96%AD%E5%9B%BEG%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">任务四（判断图G的连通性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%94%E3%80%81%E5%85%AD"><span class="toc-number">1.1.5.</span> <span class="toc-text">任务五、六</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">完整代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">1.3.</span> <span class="toc-text">测试结果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">任务一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">任务二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">任务三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%9B%9B"><span class="toc-number">1.3.4.</span> <span class="toc-text">任务四</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%94%E3%80%81%E5%85%AD-1"><span class="toc-number">1.3.5.</span> <span class="toc-text">任务五、六</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/01/godot-first-game-01/" title="使用Godot制作第一个2D游戏 01"><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/images/cover_dog_6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Godot制作第一个2D游戏 01"></a><div class="content"><a class="title" href="/2025/04/01/godot-first-game-01/" title="使用Godot制作第一个2D游戏 01">使用Godot制作第一个2D游戏 01</a><time datetime="2025-04-01T14:40:05.000Z" title="发表于 2025-04-01 22:40:05">2025-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/06/memory-palace/" title="宫殿记忆法"><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/posts/memory-palace/memory-palace-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="宫殿记忆法"></a><div class="content"><a class="title" href="/2025/03/06/memory-palace/" title="宫殿记忆法">宫殿记忆法</a><time datetime="2025-03-06T12:15:25.000Z" title="发表于 2025-03-06 20:15:25">2025-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/27/mars-survival-guide/" title="火星生存指南--火星救援"><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/posts/mars-survival-guide/mars-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="火星生存指南--火星救援"></a><div class="content"><a class="title" href="/2024/11/27/mars-survival-guide/" title="火星生存指南--火星救援">火星生存指南--火星救援</a><time datetime="2024-11-27T03:13:26.000Z" title="发表于 2024-11-27 11:13:26">2024-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/19/commands-used-4-training/" title="服务器上模型训练的常用命令"><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/posts/commands-used-4-training/com-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服务器上模型训练的常用命令"></a><div class="content"><a class="title" href="/2024/11/19/commands-used-4-training/" title="服务器上模型训练的常用命令">服务器上模型训练的常用命令</a><time datetime="2024-11-19T08:58:24.000Z" title="发表于 2024-11-19 16:58:24">2024-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/12/ozymandias/" title="OZYMANDIAS 奥西曼迭斯"><img src="https://moonglowshadow.oss-cn-qingdao.aliyuncs.com/planz/source/posts/ozymandias/ozy-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OZYMANDIAS 奥西曼迭斯"></a><div class="content"><a class="title" href="/2024/11/12/ozymandias/" title="OZYMANDIAS 奥西曼迭斯">OZYMANDIAS 奥西曼迭斯</a><time datetime="2024-11-12T13:36:55.000Z" title="发表于 2024-11-12 21:36:55">2024-11-12</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">©2020 - 2025 By 青椒肉丝</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.2.2"></script><script src="/js/main.js?v=5.2.2"></script><script src="/js/tw_cn.js?v=5.2.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><div id="moon-aplayer" class="aplayer no-destroy" data-id="13355291265" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrctype="0" data-listfolded="true" data-mutex="true"></div><script src="/js/jquery.js"></script><script src="/js/footer.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/playlist/"]):not([href="/2024/11/27/mars-survival-guide/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章或关键字" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.2.2"></script></div></div></body></html>